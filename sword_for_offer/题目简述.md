(from https://github.com/caipengbo/Coding-Interviews/blob/master/README.md)
(note: oj https://github.com/yanring/jianzhi-Offer-Leetcode?tab=readme-ov-file)
剑指offer精简总结
------
# 说明：
- 所用图书：剑指offer第二版
- 括号内是考察的知识点
- 题目前加 * 代表该题需要着重去理解（*的数目代表着重理解程度）
- 标红（下划线）的地方是需要着重理解
- 添加与LeetCode对应的题号（虽然目前LeetCode有剑指offer专题，但是题解较少）

# 3． 数组中的重复数字（数组）

## 3.1 判断重复数字（桶的思想）

长度为 n 的数组数字范围在0 —— n-1范围内，存在某些（不知道几个也不知道那些）数字重复，返回任意一个重复数字。

思路：0 — n-1是重点，可以让数字与下标各就各位（类似于桶），然后判断下标与数字是否相等，如果不相等，就与正确的位置进行交换（若原本正确位置的元素是正确的，说明这个数字重复了）。

## 3.2 *不修改数组找到任意重复数字（鸽巢原理，二分查找）

n+1 长度的数组在 1 —— n 范围内，一定存在重复数字（一个或多个），找出任意一个重复数字，不能修改数组！

## 补充：缺失的第一个正数
LeetCode41题(hash章节)：给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。

# 4.二维数组中的查找（有序数组，搜索）

LeetCode240：二维数组中，每一行是有序的，每一列也是有序的，在此二维数组中查找是否存在某一整数target。

# 5. 替换空格（字符串，双指针）

题目请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

不可以用从前往后替换的O(n2)算法（从前往后替换，在数组中需要逐步后移元素）


# 6. 从尾到头打印链表（链表，栈）

思路：后递归（系统栈）；使用栈

# 7. 重建二叉树（树，遍历）

从二叉树的前序遍历和中序遍历的结果重建二叉树。LeetCode105

考察：二叉树的遍历（三种遍历的特点都要烂熟于心），前中，后中有唯一的二叉树，前后序列重建的二叉树不唯一。

树的问题本质是一个分治（分解成左右子树），然后使用递归更简单

# 8. 二叉树的下一个节点（树，遍历，迭代）

给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

考察：对于二叉树中序遍历的深入理解，如果没有指向父节点的指针，那么可以直接使用一个TreeNode pre指针，当pre为target时候，cur就是下一个节点。


# 9. 用两个栈实现队列（数据结构，栈，队列）

用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

相近题目：LeetCode225：使用一个队列模拟栈：push或者pop的时候，倒过来

# 10. 斐波那契数列（迭代写法，DP）

递归效率比较低，需要进行大量的重复运算，本题考查的是迭代写法。

这其实是状态压缩后的DP。

# 11. *旋转数组的最小数字（二分）

把一个数组最开始的若干个元素搬到数组的末尾，称为数组的旋转。求一个增序排序（数组中有可能含有重复）的数组的旋转数组的最小数字。LeetCode153, LeetCode154

# 12. 矩阵中的路径（回溯）

请设计一个函数，用来判断在一个矩阵中**是否存在一条**包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子，LeetCode79。

路径条数：DP（LeetCode62，LeetCode63）

# 13. *机器人的运动范围（DFS）

地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？

# 14. 剪绳子（贪心，DP）

给你一根长度为n的绳子，请把绳子剪成m段 (m和n都是整数，n>1并且m>1) (m 并不是指定的) 每段绳子的长度记为 k[0],k[1],...,k[m-1]. 请问 k[0]*k[1]*...*k[m-1]可能的最大乘积是多少？

# 15. 二进制位中1的个数（位运算）

统计一个整数，二进制表示后，1的个数。
> 若n每次右移一位与1相&，当n为负数的时候，根据语言的特性，最高位补0还是补1不太好确定。

# 16. *数值的整数次方（数学）

不使用库函数，求 double pow(int base, int exponent)  , 不用考虑大数情况LeetCode50。

# 17. 打印1到最大的n位数（递归，字符串）

输入数字n, 按顺序打印出从1到最大的n位十进制数，比如数3，则打印出1，2,3….一直到3位数最大即999（相似题目LeetCode400）

考察点：考虑问题的全面性，溢出问题（大数）；打印问题（前导零）。

# 18. 删除链表的节点（链表）

链表的基本操作，Dummy Node的使用

## 18.1 在O(1)时间内删除链表节点

给定节点, O(1)时间删除该节点LeetCode237。

## 18.2 删除排序链表重复节点

删除排序链表重复节点(重复的节点不保留、保留一个)。排序说明重复的节点都在一起。

**LeetCode83重复节点仅保留一个：**

**重复节点不保留(较难)**：找到出现非重复元素的地方，如果pre和p相连（pre.next==p）说明p是非重复的（未移动）；否则的话，pre后面肯定有重复的元素，就让pre跳过**当前**重复的元素（例如0,1,1,2,2，pre.next会指向第一个2，然后pre再指向null）
pre = p.next, 然后 p 一直往前走，直到遇到p.val != p.next.val 说明碰到非重复的了，此时pre.next = p.next;

# 19. *正则表达式匹配（字符串，DP）

请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配，LeetCode10。

# 20. *表示数值的字符串（字符串，模式匹配）

请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是LeetCode65。

考点：自动机，表驱动法。

# 21. 调整数组顺序使奇数位于偶数前面（数组，双指针）

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。拓展：并保证奇数和奇数，偶数和偶数之间的相对位置不变。

# 22. 链表中倒数第 K 个结点（链表，双指针）

输入一个链表，输出该链表中倒数第 k 个结点（从 1 计数）。

# 23. *链表中环的入口节点（链表，双指针，快慢指针）

## 23.1 判断链表中是否有环LeetCode141

## 23.2 找到链表中环的入口节点

## 23.3 找到两个单链表相交的起始节点

见第52题两个链表的第一个公共结点

# 24. **反转链表（链表）

# 25. 合并两个排序的链表（链表，归并）

输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则LeetCode21。

# 26. 树的子结构（树）

输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）LeetCode572


# 27. 二叉树的镜像（树）

操作给定的二叉树，将其变换为源二叉树的镜像（反转二叉树）LeetCode226。

# 28. 对称的二叉树（树，递归）

如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。请实现一个函数，用来判断一颗二叉树是不是对称的LeetCode101。


# 29. 顺时针打印矩阵（控制，边界）

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字LeetCode54。

考点：画图分析问题，边界的判断(使用四个边界)，代码的组织。

# 30. 包含min函数的栈（栈）

定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数( 时间复杂度应为 O(1) )LeetCode155。

# 31. 栈的压入、弹出序列（栈，模拟）

两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字**均不相等**。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列（注意：这两个序列的长度是相等的）。

# 32. 从上到下打印二叉树（层次遍历，队列）

## 32.1 从上到下打印

按每一层的顺序依次打印二叉树，不用区分每一行

## 32.2 按行打印LeetCode102

每一层是一行，打印二叉树，使用队列，每次求得queue.size( )即可，循环一下即可。

## 32.3 之字形打印LeetCode103

即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行。

# 33. **二叉搜索树的后序遍历序列（BST，遍历）

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。

如果面试题要求处理一棵二又树的遍历序列，则可以先找到二叉树的根节点，再基于根节点把整棵树的遍历序列拆分成左子树对应的子序列和右子树对应的子序列，接下来再递归地处理这两个子序列。本题应用的是这种思路，第7题“重建二叉树"应用的也是这种思路。

> 本题是后序遍历，所以最后一个元素肯定是整个当前树的根节点

# 34. 二叉树中和为某一值的路径（树，遍历，回溯）
LeetCode112、113：输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

# 35. 复杂链表的复制（链表、复制、拆分）

LeetCode138：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点）, 返回结果为复制后复杂链表的 head。

**重点：链表的拆分（推荐写法）**：设置两个节点每次都移动两格，最后进行封尾。

**相似拓展：两两交换链表中的节点**

LeetCode24：给定一个链表，两两交换其中相邻的节点，并返回交换后的链表；不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

# 36. *二叉搜索树与双向链表（树，链表）

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

> 本质上还是树的遍历，BST的中序遍历序列是一个单调序列。难点：如何记录前一个节点？

# 37. 序列化二叉树（树）

LeetCode297：请实现两个函数，分别用来序列化和反序列化二叉树。

考察遍历，序列化就是遍历字符串，将值存在字符串中; 反序列化就是按照序列化的遍历顺序，构造树。

# 38. 字符串的全排列（回溯）

LeetCode46题是不带重复的全排列，LeetCode47： 带重复的全排列

> 难点如何去重？ 回溯剪枝

**对于无重复值的情况**
把第一个字符与后面每一个字符交换，获得一个排列；然后固定第一个字符，递归求后面的字符串组合。

**假如有重复值呢？**
例如abb，第一个字符与后面两个字符交换得bab，bba。然后abb中第二个字符和第三个字符相同，就不用交换了。但是对 bab，第二个字符和第三个字符不同，则需要交换，得到 bba。由于这里的bba和开始第一个字符与第三个字符交换的结果相同了，因此这个方法不行。

解决办法：对 abb，第一个字符a与第二个字符b交换得到 bab，然后考虑第一个字符与第三个字符交换，此时由于第三个字符等于第二个字符，所以第一个字符就不再用与第三个字符交换了。再考虑bab，它的第二个字符与第三个字符交换可以解决bba。此时全排列生成完毕！

修改的策略：第一个字符起，每个字符分别与它后面的字符交换，如果后面的字符中有重复的字符，那么第一个字符仅与其中的**一个**进行交换，跳过其他重复的。

如何判断重复？在每次递归中，都设置一个hash，记录交换过的字符，下次再遇到的时候，就跳过去。
# 39. 数组中出现次数超过一半的数字（快排，分割算法，递归）

LeetCode169：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

# 40. 最小的K个数（堆，快排partition）

输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。

# 41. *数据流中的中位数（堆）

LeetCode295: 如何得到**一个数据流**中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值**排序**之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值**排序**之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法 获取当前读取数据的中位数。

# 42. 连续子数组的最大和（数组，DP）

LeetCode53: 计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。{1,-2,3,10,-4,7,2,-5} 最大子数组为 {3,10,-4,7,2} = 18。 给一个数组，返回它的最大连续子序列的和。

DP：前面加的比当前数字还要小，抛弃前面的，累加从当前数字开始；不断更新maxSum，最终返回maxSum。

# 43. *整数中1出现的次数（数字，规律，位）

求出1~N的十进制整数中1出现的次数。例如：1 ~ 13中包含1的数字有1、10、11、12、13，1出现了共出现6次（11出现了两次）。

# 44. 数字序列中某一位的数字（数字，规律）

数字以`0123456789101112131415161718192021222324252627282930...`，问该序列的 第 n(从0开始) 位置是什么数字。

# 45. 把数组排成最小的数（排序）

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323{321,32,3}。

# 46. 把数字翻译成字符串（DP）

本题包括了0，相比于LeetCode91题要简单一些（需要处理0 特殊的情况），单序列DP问题，不同的条件使用不同的递推公式，当然也需要判断一下前缀0。

# 47. 礼物的最大价值（DP）

LeetCode64：很典型的二维棋盘类DP问题

# 48. 最长不含重复字符的子字符串（双指针、滑动窗口）

LeetCode第3题，使用两个指针p, q，没有重复的时候q++,有重复的时候p++，使用一个字典记录是否重复。 

# 49. 丑数（空间换时间）

把只包含质因子2、3和5的数称作丑数（Ugly Number），例如 6、8 都是丑数，但 14 不是，因为它包含质因子 7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。

# 50. 第一个只出现一次的字符（哈希）

## 50.1 第一个只出现一次的字符

在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）。

## 50.2 字符流中第一个不重复的字符

请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。

# 51. *数组中的逆序对（分治，归并）

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出 P%1000000007

# 52.  两个链表的第一个公共结点（链表，双指针）

如果两个链表没有交点，返回 null; 在返回结果后，两个链表仍须保持原有的结构,可假定整个链表结构中没有循环; 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。如果使用 hash 很简单。

# 53. 在排序数组中查找数字（二分）

## 53.1 数字在排序数组中出现的次数（二分）

统计一个数字在排序数组中出现的次数。

## 53.2 求0 —— n中缺失的数字（二分）

长度位 n的数组递增排序数组，所有数字都是唯一的，且都在0- n范围内，求缺失的那个数字。

## 53.3 递增数组中数值与下标相等的元素（二分）

一个单调递增数组的每个元素都是**整数** 并且唯一，找到任意一个数值等于其下标的元素。

> 注意本题是整数，其数组变化率必然是大于1的

# 54. 二叉搜索树的第 k 个结点（树，BST）

给定一棵二叉搜索树，请找出其中的第k小的结点。

# 55. 二叉树的深度（递归）

## 55.1 二叉树的深度

递归，递归求左子树深度，求右深度，返回较大的深度+1。

## 55.2 判断是否是平衡二叉树

思路：左右子树深度不超过1，返回值代表高度，如果高度为-1，说明不是平衡点，提前中断，直接返回，否则更新高度。

# 56. 数组中数字出现的次数（数组，位运算）

掩码求每一位，异或，HashMap中的位运算，将整数变成比它大的2次幂；

## 56.1 数组中只出现一次的两个数字（异或）

一个整型数组里除了两个数字之外，其他的数字都出现了**两次**。请写程序找出这两个只出现一次的数字。

**先考虑**：数组中除了一个数字之外其他数字都出现了两次，求这一个数字，这个很明显使用异或。最后求得的值就是这个只出现一次的数字。

## 56.2 *数组中唯一只出现一次的数字（与）

一个整型数组里除了一个数字之外，其他的数字都出现了三次。请写程序找出这个只出现一次的数字。

# 57. 和为s的数字（双指针）

## 57.1 和为 S 的两个数字

输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。对应每个测试案例，输出两个数，小的先输出。

## 57.2 和为 S 的连续正数序列（滑动窗口，双指针）

输出所有和为S的连续正数序列(至少含有两个数字)。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。

# 58. 翻转字符串（数组，旋转）

## 58.1 翻转每一个单词

输入一个英文句子，翻转句子中英语单词的顺序(标点符号和普通字母一样处理),例如： I am a student. -> student. a am I。

## 58.2 左旋转字符串（两次反转）

对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”

思路：字符串 “123456”，左旋转2位；分成两部分12|3456各部分翻转21|6543， 翻转整个字符串3456|12

# 59. 队列的最大值（单调队列，滑动窗口）

## 59.1 *滑动窗口的最大值

给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。O(nk)算法比较简单，如何优化？使用双向队列，因为需要从头和尾部删除元素。
单调队列的典型用法

## 59.2 队列的最大值

求队列的最大值，实现 max  push_back  pop_front 函数。

> Warning: 本题出现了一个重大的错误，由于使用Deque，元素是Integer，使用了 == 去比较了（Integer有缓存池，小于255的才会==，否则是不相等的），导致出现了错误！！！

# 60. n个骰子的点数（DP）

LeetCode 1155题，类似于背包问题。使用记忆化递归更简单直观。

背包问题：01背包

# 61. 扑克牌中的顺子（排序）

从扑克牌中抽5张牌，判断是不是顺子，2~10看成数字本身，A看做 1，J看做11，Q看做12，K看做13，大小王看成任意数字。

> 注意尽量使用少的变量，sum zero  可以只用zero与0比较，不用zero和sum比较

# 62. 圆圈中最后剩下的数字（链表，约瑟夫环） 

0, 1, 2, n-1 这 n 个数字排成一个圆圈，从数字0开始，每次从这个圆圈删除第m个数字，求这个圆圈里剩下的最后一个数字。

# 63. 股票的最大利润（数组，DP）

把股票的价格按照**时间先后**顺序存储在数组中，请问买卖该股票 1 次可以获得的最大利润是多少？ 一只股票在某时间节点的价格是{9,11,8,5,7,12,16,14}，在价格为5 的时候买入并在价格为16 的时候卖出，最大利润为11。   

# 64. 求1+2 … + n

1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。


# 65. *不用加减乘除做加法（位运算）

一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。   

# 66. 构建乘积数组（数组，空间换时间）

给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1], 其中B中的元素 B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。 不能使用除法。注：n=1时候，B={1}

# 67. 将字符转化成整数

- 第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号
- 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。
- 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、
- 字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。
- 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。
如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。d


# 68. 二叉树的最近公共祖先

- 求二叉搜索树的最近公共祖先？
- 求普通二叉树的最近公共祖先？
